# Бот для Яндекс.Алиса
##Предварительная настройка
### Морфологический словарь
```php
//По умолчанию
$bot = new Alisa('NAME');
$bot->setDictionaryPath($_SERVER['DOCUMENT_ROOT'] . '/dicts/');
```

### Директория хранения сессий
```php
//По умолчанию
$bot = new Alisa('NAME');
$bot->setDictionaryPath($_SERVER['DOCUMENT_ROOT'] . '/sessions/');
```


## Протокол работы

```php
//Создаем бота. Аргумент – название навыка
$bot = new Alisa('myawesomebot');

//Создаем триггер, в качестве аргумента строка с уникальным именем
$helloTrigger = new Trigger('HELLO');

//Привязываем к триггеру токены – в данном случае в одну группу.
//Токены – ключевые слова, объединенные в группы
$helloTrigger->linkTokens(['привет','здравствуйте','приветсвую']);


$bayTrigger = new Trigger('bay');
$bayTrigger->linkTokens(['пока','до свидания','прощай']);

//Привязываем триггеры боту
$bot->addTrigger($helloTrigger,$bayTrigger);

//Отправляем ответ, если распознан $helloTrigger
$bot->sendResponse($helloTrigger,static function(){
    //$answer - экземпляр отправляемого ответа

    $answer = new Response();
    $answer->addText('Привет!');
    $answer->addText('Доброго времени суток!');

    //обязательно возвращаем объект Response
    return $answer;
);

//Отправляем ответ, если распознан $bayTrigger
$bot->sendResponse($bayTrigger,static function(){
    $answer = new Response();
    $answer->addText('Прошай!');
    $answer->addText('Всего доброго');

    //обязательно возвращаем объект Response
    return $answer;
);
```
## Стандартные триггеры
По протоколу работы бот обязан иметь как минимум триггер для приветствия, обработку ошибки (вызов помощи).

```php

//Будет вызван автоматически, при первом обращении пользователя к навыку
$helloTrigger = new Trigger('HELLO');
$helloTrigger->setAsInit(true);

//Будет вызыван автоматически, если ну удалось распознать запрос
$mistakeTrigger = new Trigger('MISTAKE');
$mistakeTrigger->setAsMistake(true);


//Отправляем ответ, если распознан $mistakeTrigger
$bot->sendResponse($mistakeTrigger,static function(){
    $answer = new Answer();
    $answer->addText('Не удалось понять вашу команды :( ');
    return $answer;
);
```
В случае, если данные триггеры не определены, бот отошлет ответ по умолчанию с ссылкой на данный пункт. И если это причина, по которой ты читаешь этот текст – шалость удалась.
##Триггеры
Триггер – команда, на которую должен отреагрировать бот.
###Токены
Токены – ключевые слова, или варианты запроса (зависит от выбранного типа распознования)
#### MORPHY_STRICT
Данный режим использует поочередное сравнение групп токенов, отбирая только подходящие варинты. Разбор идет слева направо – если первая группа не прошла поиск – остальные группы перебираться не будут и бот приступит к просмотру следующего триггера. При первом вхождении всех групп – триггер будет помечен как распознанный, остыльне учавствовать в разборе не будут  
```php
$greenTea->addTokens(['дай','хочу','налей'],['чай'],['зеленый']);
$blackTea->addTokens(['дай','хочу','налей'],['чай'],['черный','индийский']);
$coffeTrigger->addTokens(['дай','хочу','налей'],['кофе']);
```
При запросе "Налейка, пожалуйста черного чая" сработает $blackTea;
При запросе "Сил нет как хочу бодрящего такого кофе" – $coffeTrigger;

Плюсы:
* Хорошо различает очень похожие запросы
* При первом свопадении всех групп токенов, обработка следующих триггеров прекращается
* Очередностью добавления триггеров можно определить те триггеры, которые будут обрабатываться первым. См пункт выше.
* Может вызывать триггер с ошибкой, если команда не была распознана. В данном примере, попросив налить пива, бот скажет что такими полномочиями не обладает.

Минусы:
* Необходимо строго определять важность того или иного ключевого слова. В случае с $greenTea и $blackTea, с аналогичными двумя первыми группами, решающим фактором сыграет третья гурппа токенов – черный чай или все таки зеленый.
* И колличество триггеров, и колличеество групп токенов сказывается на скорости работы.

#### Дамерау-Левенштейн
В отличие от MORPHY_STRICT ключевые слова будут определяться автоматически, но необходимо прописать несколько вариантов запросов. В разборе учавствуют все триггеры, за распознный будет выбираться триггер с наилучшим совпаденеием запроса.

```php
$greenTea->addTokens(['Налей зеленого чая'],['Хочу зеленого чая'],['Дай зеленый чай']);
$blackTeas->addTokens(['Налей чергого чая'],['Хочу черного чая'],['Дай черный чай']);
$coffeTrigger->addTokens(['Налей кофе'],['Хочу кофе'],['Дай кофе']);
```
Плюсы:
* Не нужно определять группы ключевых слов. Достаточно прописать только несколько возможных вариантов, которые может запросить пользователь
* Как правило, запрос обрабатывается быстрее, чем аналогичная вариация MORPHY_STRICT

Минусы:
* Обрабатываются все триггеры, для которых прописаны токены. Даже если правильный триггер был выбран первым, остальные триггеры все равно пройдут проверку. Результирующий триггер – триггер с наибольшим совпадением. Соответвено чем больше триггеров, тем медленее работает.
* В отличие от MORPHY_STRICT не может вызывать сообщение с ошибкой распознования. Данный режим всегда выдает какой-либо триггер. В данном примере, попросив налить пива, по какой-то причине бот наливает кофе.
 
###Делегирование
В случаях, когда бот используется для последовательного выполнения команд, можно привязать к триггеру следующий триггер. Например если нужно собрать какую-либо информацию от пользователя, например имя, фамилию итд.

```php
//Деклаириуем триггеры
$nameTrigger = new Trigger('NAME');
$sNameTrigger = new Trigger('SECOND_NAME');
$yoTrigger = new Trigger('YEARS');

//Назначаем токены для триггера 
$nameTrigger->setTokens(['давай','хочу','может'],['знакомиться','познакомиться','представлюсь']);

//Привязываем следующие триггеры
$nameTrigger->nextDelegate($sNameTrigger);
$sNameTrigger->nextDelegate($yoTrigger);
$yoTrigger->nextDelegate($personTrigger);
```
Для каждого из триггеров нужно создать обработчик с вопросом. При запросе пользователя "Ну давай познакомимся" сработает триггер $nameTrigger. Для триггеров $sNameTrigger и $yoTrigger токены не нужны (в общем то в данном случае они и не смогут сработать, тк пользотваель будет передавать информацию, и в ней нельзя распознать команду), они будут вызваны автоматически друг за другом.

 
###Данные
Триггеры можно использовать не только как способ определения команды пользователя, но и для сбора информации.

```php

//$personTrigger – назначен как следующий триггер после $yoTrigger
$bot->sendResponse($personTrigger,static function() use ($bot){

    //В качестве аргумента строка, уникальное название триггера
    $name = $bot->getTriggerData('NAME');
    $sName = $bot->getTriggerData('SECOND_NAME');
    $yo = $bot->getTriggerData('YEARS');
    $answer = new Answer();
    $answer->addText("Хорошо {$name} {$sName}, я тебя запомнила, и что тебе {$yo} лет – тоже");
    return $answer;
);
```
Бот сохраняет только один экзмепляр данных для триггера, таким образом получить можно только последние полученные данные
##Ответы
Ответы – это информация, которую бот отсылает пользователю, как только сработал триггер.
###Текст и TTS

```php

//$personTrigger – назначен как следующий триггер после $yoTrigger
$bot->sendResponse($personTrigger,static function() use ($bot){
    $answer = new Answer();
    $answer->addText('Один вариант ответа','Од!ин вари!ант отв!ета');
    return $answer;
);
```
В методе addText два строчных аргумента. Первый используется для вывода текста, который будет отображен пользователю, второй – тот же самый текст в формате TTS.
###Варианты
Для большей интерактивности следует использовать несколько возможных вариантов ответа. Вариант при отправке будет выбран случайно.
```php

$bot->sendResponse($bullshitTrigger,static function() {
    $answer = new Answer();
    $answer->addText('Да не может быть!');
    $answer->addText('Чушь собачья!');
    $answer->addText('Не верю!');
    return $answer;
);
```
###Кнопки
Для ответа можно прикрепить кнопку. Это может быть ссылка на веб-страницу или кнопка, при нажатии на которую будет вызван триггер. Кнопок может быть несколько и разных видов.
```php

$bot->sendResponse($helloPerson,static function() {
    $answer = new Answer();
    $answer->addText('Может познакомимся?');
    $buttonY = new Button('Давай');
    $answer->addButton($button);
    $buttonN = new Button();
    $buttonN->setTitle('Неа');
    return $answer;
);
```
В данном примере при при нажатии на кнопку будет вызван $nameTrigger из примера в пункте "Делегирование". Таким образом $nameTrigger может быть взыван как голосом пользователя, так и нажатием на кнопку, если пользователь не разговорчив.
##Кнопки
###Базовые возможности
###Виды кнопок

##Сохранение данных
Помимо отправленных пользователем данных, которые привязывается и сохраняеются триггером, можно сохранить и свои данные.
```php

$bot->sendResponse($firstRequest,static function() use($bot) {
    * * *
   $bot->storeCommonData('Черный чай','TEA');
   $bot->getCommonData('TEA'); // Вернет "Черный чай", в т.ч. если пользователь уже перешел к другому запросу
    * * *
);
```

```php

$bot->sendResponse($secondRequest,static function() use($bot) {
    * * *
   $bot->getCommonData('TEA'); // Вернет "Черный чай", в т.ч. если пользователь уже перешел к другому запросу
    * * *
);
```

##Больше возможностей
###Зацкиливание триггера
В случаях, когда триггер предполагает не только принятие данных, но и валидацию, следует испольовать зацикливание
```php
//Допустим что код триггера $chooseMeds – "MEDS"
$bot->sendResponse($chooseMeds, static function () use ($bot) {
    $answer = new Response();

    //Проверяем, это первичный запрос или цикл?
    if ( ! $bot->isRepeatedRequest()) {
        //Нет, значит это первичный запрос со стороны пользователя, предлагаем выбор
        $answer->addText('Какую таблетку ты выберешь, Нео?');
        //Задаем циклирование, результат будем проверять в этом же триггере
        $bot->setRepeat(true);
    } else {
        //Неправильный выбор?
        if ($bot->getTriggerData('MEDS') !== 'Синяя') {
            $answer->addText('Неверный выбор, Нео');
            //Задать цикл
            $bot->setRepeat(true);
        } else {
            //Все ок, выход из триггера
            $answer->addText('Ты сделал правильный выбор о-о');
        }
    }
    return $answer;
});
```
###Внутреннее делегирование

###Ручная подстановка данных для триггера

###Пост обработка ответа


